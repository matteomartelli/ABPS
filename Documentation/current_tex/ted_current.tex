\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{float}
\usepackage{bytefield}
\usepackage{fullpage}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{bytefield}
\usepackage{enumerate}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{txfonts}

\title{Supporto alla Frammentazione in TED }
\author{Matteo Martelli}

\begin{document}
\lstset{
	language=C, 
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\bfseries,
    showstringspaces=false,
	stringstyle=\color{red}\ttfamily,
    commentstyle=\color{Gray}\ttfamily
}
\maketitle


\section{Nelle puntate precedenti}
In questo documento verrano esposte le modifiche riguardanti la
frammentazione apportate al componente software TED 
(Transmission Error Detector). Per maggiori informazioni su TED e
sull’architettura ABPS (Always Best Packet Switching) si rimanda alla documentazione
dei lavori precedenti\cite{dibernardotesi,mengolitesi,abps}.\\

In sintesi TED offre, tramite una struttura cross-layer, un meccanismo in grado di fornire informazioni 
alle applicazioni riguardo l’avvenuta (o mancata) consegna al primo access point dei datagram
UDP trasmessi.

Quando l’applicazione invia un datagram UDP, TED lo marca con un identificativo user-space accessibile 
dall’applicazione. Successivamente ogni frame 802.11 spedito dall’interfaccia di rete viene
associato a quell’identificativo e ad una struttura dati contenenti
informazioni sullo stato del frame.
Quest’ultime vengono poi integrate con le informazioni riguardanti l’avvenuta o mancata consegna (ACK,
NACK) del frame all’access point e il relativo numero di tentativi
di consegna.\\

Nelle versioni precedenti a questa mancava il corretto supporto per la gestione della frammentazione
in IPv6. Vedremo nella prossima sezione quali modifiche sono state apportate al kernel per il corretto
funzionamento con 	 la frammentazione in IPv6. Come nella versione
precedente lo sviluppo è stato continuato per il kernel 4.0.1.

Infine nella sezione \ref{sec:app} vedremo le modifiche apportate all’applicazione per la gestione delle notifiche
di TED dei datagram frammentati oltre a qualche esempio d’utilizzo.\\

Il codice sorgente parzialmente mostrato in questo documento è
attualemente ospitato nel repository \\ 
\url{https://github.com/matteomartelli/ABPS-4.0} nato come un fork della
versione precedente portata avanti da Gabriele Di Bernardo e Alessandro
Mengoli.

\newpage
\section{Modifiche Kernel}
Prima di mostrare le modifiche effettuate nel kernel ricordiamo
brevemente come sono formati gli header dei pacchetti IPv6.

\subsection{Header IPv6}
In particolare siamo interessati all'header del pacchetto IP che nella
versione 6 è composta da un parte fissa (fixed) e una parte variabile
formata da header opzionali chiamati extension header. 

La figura \ref{fig:fixedhdr} mostra il formato del fixed header IPv6. 

\begin{figure} [H]
	\begin{center}
		\begin{bytefield}[bitwidth=1.1em]{32}
			\bitheader{0-31}\\
			
			\bitbox{4}{Version}
			\bitbox{8}{Traffic Class}
			\bitbox{20}{Flow Label}\\
			
			\bitbox{16}{Payload Length}
			\bitbox{8}{Next Header}
			\bitbox{8}{Hop Limit} \\
			
			\wordbox{4}{Source Address} \\
			\wordbox{4}{Destination Address} \\
		\end{bytefield}
		\caption{Formato fixed header IPv6.}
		\label{fig:fixedhdr}
	\end{center}
\end{figure}

Notiamo che a differenza dei pacchetti IPv4 non sono presenti i campi
\emph{Flags} e \emph{Fragment Offset} utilizzati nella versione 4 per
ottenere informazioni sulla frammentazione. Per tale scopo, in IPv6, bisogna far
riferimento all'extension header \emph{Fragment}, mostrato in figura
\ref{fig:fragmenthdr}, nel quale sono
contenute le informazioni necessarie per riasseblare i pacchetti
originali.
\begin{figure} [H]
	\begin{center}
		\begin{bytefield}[bitwidth=1.1em]{32}
			\bitheader{0-31}\\
			
			\bitbox{8}{Next Header}
			\bitbox{8}{Reserved}
			\bitbox{13}{Fragment Offset}
			\bitbox{2}{Res}
			\bitbox{1}{M} \\

			\wordbox{1}{Identification} \\
		\end{bytefield}
		\caption{Formato fragment extension header IPv6.
I campi \emph{Res} e
\emph{Reserved} indicano spazio riservato inizializzato a 0. Il campo
\emph{M} si riferisce al campo \emph{More Fragment}.}
		\label{fig:fragmenthdr}
	\end{center}
\end{figure}
Gli extension header sono situati tra il fixed header e gli header dei
protocolli di livello superiore. Tramite il campo \emph{Next Header} gli header
formano una catena. In particolare il campo \emph{Next Header} del fixed
header indica il tipo del primo extension header e il \emph{Next Header}
dell'ultimo extension header (o del fixed header ove non ci fosse nessun
extension header) indica il tipo dell'header del protocollo di livello
superiore (ad esempio TCP o UDP).
\newpage
\subsection{Frammentazione IPv6 in TED}
La modifica principale risiede nella funzione
\texttt{ipv6\_get\_udp\_info} la quale si occupa di recuperare le
informazioni sul frammento IPv6 del relativo frame 802.11
 al momento del suo invio.\\

Nella nuova versione si scorre innanzitutto la catena degli header fino
ad incontrare l'header fragment:
\begin{lstlisting}
/* Variables initialization */
*fragment_offset = *more_fragment = hdrs_len = error = 0;
nexthdr = ipv6_hdr(skb)->nexthdr;
target = NEXTHDR_FRAGMENT;

do {
	struct ipv6_opt_hdr _hdr, *hp;
	unsigned int hdrlen;
	found = (nexthdr == target);

	if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {
		break;
	}

	hp = skb_header_pointer(skb, offset, sizeof(_hdr), &_hdr);
	if (hp == NULL) {
		error = -EBADMSG;
		break;
	}

	if (nexthdr == NEXTHDR_FRAGMENT) {
		hdrlen = 8;
	} else if (nexthdr == NEXTHDR_AUTH) {
		hdrlen = (hp->hdrlen + 2) << 2;
	} else
		hdrlen = ipv6_optlen(hp);

	if (!found) {
		nexthdr = hp->nexthdr;
		offset += hdrlen;
	}

	hdrs_len += hdrlen;
} while (!found);
\end{lstlisting}

In realtà questa operazione è un
controllo di sanità in quanto secondo le specifiche dell'RFC 2460\cite{rfc2460}
l'header fragment
dovrebbe essere il diretto successore del fixed header. 
Ad ogni modo dopo aver indivuato l'header fragment si può accedere alla
bitmap \texttt{frag\_off} della relativa struttura dati. Tramite la
bitmap si possono ottenere quindi il campo \emph{Fragment Offset} e il
campo \emph{More
Fragment} del frammento:

\begin{lstlisting}
/* fh is the pointer to the fragment header struct and it is retreived
according to the offset from the begging of the packet */
fh = skb_header_pointer(skb, offset, sizeof(_frag), &_frag);

if (fh) {
	*fragment_offset = ntohs(fh->frag_off) & ~0x7;
	*more_fragment = ((fh->frag_off & htons(IP6_MF)) > 0);
} 
\end{lstlisting}
 
Infine l'ultimo campo che ci interessa ottenere è la lunghezza del
frammento. La parte frammentabile è tutto quello che segue l'header
fragment, quindi eventuali altri extension header IPv6, gli header dei
protocolli dei livelli superiori e il frammento dati del messaggio.
Bisogna quindi togliere dalla dimensione del frammento indicata dal
campo \emph{Payload} del fixed header, la dimensione dell'header fragment.
Questo perchè il campo \emph{Payload} esclude già la dimensione del fixed
header e perchè l'header fragment è il diretto successore del fixed
header; inoltre tutto quello che segue va considerato parte del
frammento\footnote{Sempre per controllo di sanità, viene sotratto al
payload
tutto quello che parte dalla fine del fixed header fino alla fine
dell'header fragment.}:

\begin{lstlisting}
*fragment_data_length = ntohs(payload_iphdr->payload_len) - hdrs_len;
\end{lstlisting}

A seguito di queste modiche il kernel con TED abilitato riesce
correttamente ad ottenere le informazioni sulla frammentazione anche per
IPv6.

\section{Modifiche Applicazione}
\label{sec:app}
L'applicazione di test ha lo scopo di verificare il corretto
funzionamento di TED nel kernel. È composta da due eseguibili: un client
ed un server. Il server non fa altro che ricevere datagram UDP su una
porta specificata dall'utente ed è rimasto pressochè invariato
dalla versione precedente. Il client si occupa di inviare datagram UDP al
server sulla porta specificata e nel frattempo raccoglierne le relative 
notifiche TED.

Nel client sono state apportate molteplici modifiche nell'ultima
versione. Le principali verrano spiegate in questa
sezione.
\subsection{Gestione Asincrona delle Notifiche TED}
Innanzitutto si è dovuta modificare la gestione della
ricezione delle notifiche TED. Nella versione precedente era stata scelta
una politica sincrona, ovvero per ogni messaggio spedito si attendeva
la relativa
notifica TED prima di procedere alla spedizione del messaggio
successivo. È evidente che tale approccio aggiunge un rallentamento
notevole all'applicazione. 
Inoltre tale approccio non potrebbe essere applicato se
l'applicazione spedisse datagram UDP di dimensione maggiore del MTU
inquanto per ogni datagram spedito bisognerebbe attendere le notifiche
di tutti i frammenti (ricordiamo che TED invia una notifica per ogni
frame 802.11 spedito, quindi per ogni frammento del datagram UDP
originale).

Si è scelto quindi di passare ad una gestione asincrona delle notifiche.
Esistono diversi articoli\cite{polling1,polling2} che mostrano e
comparano i possibili sistemi per gestire in modo asincrono i socket
descriptor.
Il recente \emph{epoll} introduce varie ottimizazzioni in termini
prestazionali rispetto a \emph{select} e \emph{poll}.
Tuttavia tali ottimizzazioni sembrerebbero avere effetto solo con un
gran numero di socket e al contrario sembrano peggiorare le prestazioni con
un numero basso di socket descriptor. 

È da considerare inoltre che l'applicazione di test 
è un primo passo verso l'implementazione di un proxy client descritto da
ABPS\cite{abps} in cui il numero di socket da gestire è piccolo:
generalmente un socket per l'applicazione, e due o tre per il numero di
interfacce.

Ad ogni modo è molto interessate la gestione degli eventi in modalità edge-triggered 
introdotto da epoll. Nella modalità edge-triggered gli eventi vengono
segnalati all'applicazione solo c'è un cambio di stato nei file
descriptor monitorati. Per maggior chiarezza, vediamo di seguito un esempio di utilizzo
estratto dal man di epoll.\\
\lstset{keywordstyle=,}
\begin{lstlisting}
Suppose that this scenario happens:

	1. The file descriptor that represents the read side of a pipe (rfd) 
	   is registered on the epoll instance.
	2. A pipe writer writes 2 kB of data on the write side of the pipe.
	3. A  call  to  epoll_wait(2)  is  done  that  will return rfd as
	   a ready file descriptor.
	4. The pipe reader reads 1 kB of data from rfd.
	5. A call to epoll_wait(2) is done.

If the rfd file descriptor has been added to the  epoll  interface  using  the
EPOLLET  (edge-triggered)  flag, the call to epoll_wait(2) done in step 5 will
probably hang despite the available data still present in the file input  buffer; 
meanwhile the remote peer might be expecting a response based on the data
it already sent.
...
The suggested way to use epoll as an edge-triggered (EPOLLET) interface is as follows:
	i. with nonblocking file descriptors; and
	ii. by  waiting  for  an  event  only  after read(2) or write(2) return  EAGAIN.
\end{lstlisting}

\lstset{
	language=C, 
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\bfseries,
    showstringspaces=false,
	stringstyle=\color{red}\ttfamily,
    commentstyle=\color{Gray}\ttfamily
}
Nel caso in cui la nostra applicazione inviasse datagram UDP molto
grandi (supponiamo $N*MTU$) verso una socket $sd$, per ogni messaggio 
inviato avremmo $N$ notifiche TED provenienti dal kernel per $sd$. 
Quindi con invii di messaggi molto frequenti da parte
dell'applicazione, si potrebbe avere un gran overhead di segnalazione
eventi da parte del kernel se venisse effettuata per ogni $N$ frammenti
del messaggio originale. Utilizzando l'edge-triggered invece avremmo un
segnale solo al primo messaggio TED introdotto nella coda degli errori
(ERRQUEUE). I successivi messaggi TED verrano introdotti, senza essere
segnalati all'applicazione, nella ERRQUEUE che dovrà però venir svuotata ogni
volta che risulta essere non vuota.

In aggiunta, la scelta dell'utilizzo epoll è nata dopo aver riscontrato
problemi con l'utilizzo della direttiva \emph{select}. 
Durante i test effettuati con la direttiva
\emph{select}, gli errori sulle socket descriptor non
venivano catturati né nel \texttt{fd\_set read} né nel \texttt{fd\_set
exception}. Non era quindi possibile ottenere le notifiche TED.
Ulteriori prove e considerazioni su quale approccio utilizzare per la
gestione asincrona delle notifiche è rimandata alle versioni future.

Di seguito vediamo il main loop dell'applicazione di test:
\begin{lstlisting}
/* Main epoll loop. Wait for events on the socket descriptor.
 * If an EPOLLOUT event is triggered a new message can be sent.
 * If an EPOLLERR event is triggered some ted error message 
 * may be present in the errqueue. */
for (;;) {

	nfds = epoll_wait(epollfd, events, MAX_EPOLL_EVENTS, -1);
	if (nfds == -1)
		utils_exit_error("epoll_wait error\n");
	
	for (i = 0; i < nfds; i++) {

		/* Send a new message if the socket is ready for writing */
		if (events[i].events & EPOLLOUT && idx < conf.n_packets) {
			send_new_msg(hashtb);
			idx++;
		}

		/* If there are pending TED error messages 
		 * in the errqueue, receive them and print TED infos. */
		if (events[i].events & EPOLLERR)
			recv_ted_errors(hashtb);

	}
}

\end{lstlisting}

Essenzialmente vengono inviati un numero di pacchetti
\texttt{conf.n\_packets}
(di default o specificati dall'utente) ad un server e si controlla dopo
ogni invio se ci sono messaggi di errore, tramite l'evento EPOLLERR, per
il socket descriptor monitorato (in questo caso ne è solamente uno).
Se ci sono messaggi di errore pendenti viene invocata la funzione 
\texttt{recv\_ted\_errors()} che essenzialemente legge le notifiche TED 
dalla coda ERRQUEUE fino a che non risulta vuota (recv ritorna EAGAIN).
Per ogni notifica ricevuta l'applicazione riempie una struttura
\texttt{ted\_info\_s} che verrà utilizzata per ricomporre i frammenti
e/o fornire informazioni
sullo stato del pacchetto originale:
\begin{lstlisting}
struct ted_info_s {
	uint32_t msg_id;
	uint8_t retry_count;
	uint8_t status;
	uint16_t frag_length;
	uint16_t frag_offset;
	uint8_t more_frag;
	uint8_t ip_vers;
	char *msg_pload;
};
\end{lstlisting}

\subsection{Gestione della Frammentazione}
\label{subsec:frag}
Vediamo adesso come vengono gestite le notifiche TED dei messaggi
frammentati. Ricordiamo che per ogni messaggio UDP abbastanza grande da
venir frammentato, vengono ricevute un numero di notifiche TED pari al
numero di frammenti del messaggio originale. Lo scopo dell'applicazione
di test è quello di riassemblare le notifiche frammentate in modo da
fornire delle informazioni medie sul corrispondente messaggio
precedentemente inviato.

A tal proposito viene utilizzata un hashtable di strutture riguardanti i
messaggi inviati:
\begin{lstlisting}
struct msg_info_s {
	int size;
	uint32_t id;
	struct ted_info_s *frags[MAX_FRAGS];
	int n_frags;
	short int last_frag_received;
};
\end{lstlisting}

Quindi di ogni messaggio inviato viene salvata la dimensione
\texttt{size} e l'identificatore \texttt{id} assegnato dal
kernel. Inoltre vengono predisposte le variabili utilizzate in seguito
per ricomporre i frammenti: \texttt{frags} è un array di struct
\texttt{ted\_info\_s} le quali andranno a contenere le informazioni di
ogni singola notifica TED; \texttt{n\_frags} è il numero di frammenti
attualmente ricevuti (inizializzato a 0) e \texttt{last\_frag\_received}
è un booleano che indica se è stato ricevuto o meno l'ultimo frammento
(per posizione)\footnote{Non necessariamente l'ultimo frammento per
posizione viene ricevuto cronologicamente dopo i suoi predecessori}.\\

Oltre a memorizzare nell'hashtable ogni messaggio spedito, 
per ogni notifica TED ricevuta viene controllato se quest'ultima \underline{non} è
 una
notifica di un frammento (oppure lo è), ovvero se i valori \emph{morefrag}
e \emph{frag\_offset} risultano entrambi zero (o altrimenti).
Nel caso in cui fosse un frammento viene cercata nell'hashtable il
messaggio originale corrispondente in base all'identificatore
\texttt{msg\_id} presente nella struct \texttt{ted\_info\_s} della
notifica. Ricordiamo infatti che TED assegna ad ogni notifica
di un frammento l'id del messaggio originale.\\

Una volta riottenuta dall'hashtable la struttura \texttt{msg\_info\_s} del
messaggio
originale vi si aggiunge la struct \texttt{ted\_info\_s} della notifica
accodandola nell'array \texttt{frags}.

Questa operazione viene effettuata per ogni notifica TED di un frammento
ricevuta, finchè non vengono ricevute tutte le notifiche dei frammenti.

Se viene ricevuta la notifica del frammento che ha
valore \texttt{more\_frag} uguale a 0, ovvero l'ultimo frammento di
posizione, oppure se viene ricevuta una notifica di qualsiasi frammento
ma è già stato ricevuto l'ultimo di posizione,
si procede ad ordinare, secondo gli offset, tutti i frammenti già ricevuti. 

Se la somma delle dimensioni di ciascun frammento è uguale alla
dimensione del messaggio originale (più l'header UDP)  allora si considerano
 validi i frammenti e si calcolano la media del numero di \emph{ack} e di
\emph{retry count} del messaggio originale.
Quest'ultima operazione viene eseguita dalla funzione
\texttt{try\_recompose} riportata qui di seguito:

\begin{lstlisting}
int try_recompose(struct msg_info_s *msg_origin)
{
	...
	/* Sort fragments by the fragment offsets */
	qsort(msg_origin->frags, msg_origin->n_frags,
	      sizeof(struct ted_info_s *), compare_frags);
	
	tot_len = 0;
	acked_avg = retry_count_avg = 0.0;
	if (msg_origin->frags[msg_origin->n_frags - 1]->more_frag == 0) {
		for (i = 0; i < msg_origin->n_frags; i++) { 
			tot_len += msg_origin->frags[i]->frag_length;
			acked_avg += (float)msg_origin->frags[i]->status;	
			retry_count_avg += (float)msg_origin->frags[i]->retry_count;
		}
		acked_avg /= (float)msg_origin->n_frags;
		retry_count_avg /= (float)msg_origin->n_frags;
	}
	if (tot_len != msg_origin->size + UDP_HEADER_SIZE) {
		printf("recomposition failed.\n");
		return 0;
	}
	return 1; /* Success */

}
\end{lstlisting}


Non c'è ancora una gestione dell'errore: potrebbe accadere che arrivino
le notifiche di tutti
i frammenti ma la somma delle loro dimensioni non corrisponda alla
dimensione del
messaggio originale. Inoltre potrebbe accadere che non tutte le
notifiche arrivino. Un'idea di sviluppo potrebbe essere quella di
controllare periodicamente l'hashtable e rimuovere quei messaggi che non
hanno ricevuto tutte le notifiche entro un certo tempo limite. 
Tali considerazioni potrebbero essere rianalizzate durante lo sviluppo
delle future versioni. 
\newpage
\subsection{Refactoring e Organizzazione}
Rispetto alla versione precedente è stata effettuata una consistente
riorganizzazione e un refactoring del codice sorgente.
Innanzitutto sono state unificate le due applicazioni per IPv4 e IPv6 in
un'unica applicazione permettendo all'utente di scegliere a
ll'invocazione quale versione
utilizzare. \\

Inoltre la gestione dei log in formato json presente nella versione
precedente è stata rimossa in quanto non più applicabile con la gestione
asincrona delle notifiche TED. Per simmetria questa funzionalità è stata 
rimossa anche dal server.\\

Infine è stata riorganizzata la struttura file portando tutte le
constanti e le strutture in file header apposititi, \texttt{consts.h} e
\texttt{structs.h}, aggiungendo i sorgenti per funzioni di utilità generiche,
\texttt{utils.c/h}, e separando le funzioni di rete dalle funzioni di
gestione delle notifiche TED relativamente in \texttt{network.c/h} e
\texttt{tederror.c/h}.

\subsection{Utilizzo}
Vediamo adesso come utilizzare l'applicazione di test. Alla sua
invocazione senza argomenti o con l'argomento \texttt{-h} verrà mostrato
lo usage:

\begin{lstlisting}
Usage: sendclientapp [OPTIONS] ADDRESS PORT

OPTIONS:
    -h, --help                Print this help.
    -6, --ipv6                Use IPv6 (IPv4 default).
                                  Interface argument MUST be specified (-i).
    -i, --iface=NIC_NAME      Declare the network interface associated
                                  to the specified ip address.
    -n, --npkts=N_PKTS        Specify how many packets must be sent.
    -s, --size=PKT_SIZE       Specify how big (bytes) a packet must be.
\end{lstlisting}

Possiamo vedere che si può decidere la versione IP da testare, il numero
di pacchetti da spedire e la loro dimensione. È invece obbligatorio
specificare l'indirizzo di destinazione e la porta su cui il server è in
ascolto.\\

Per fornire un esempio consideriamo adesso il seguente scenario:
Un server $s$ è in ascolto per la ricezione di datagram UDP
all'indirizzo IPv6 \texttt{fe80::210:a7ff:fe0a:3751} e porta
\texttt{50000}. Un client $c$ è 
associato ad un access point Wi-Fi tramite l'interfaccia \texttt{wlan3} e 
fa parte della stessa rete locale di $s$.
Quindi $c$ decide di inviare 4 datagram UDP ad $s$ con l'app di test:

\begin{lstlisting}
./senclientapp -6 -i wlan3 -n 4 -s 6000 fe80::210:a7ff:fe0a:3751 50000
\end{lstlisting}

L'output del client $c$ è il seguente:
\lstset{
	basicstyle=\ttfamily\scriptsize,
}
\begin{lstlisting}
---------------------------------------------------------------------
					Sent pkt ID: 214
					size: 5999
---------------------------------------------------------------------
					Sent pkt ID: 219
					size: 5999
---------------------------------------------------------------------
TED notified ID: 214 
msg_id: 214, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 0
---------------------------------------------------------------------
TED notified ID: 214 
msg_id: 214, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 1448
---------------------------------------------------------------------
TED notified ID: 214 
msg_id: 214, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 2896
---------------------------------------------------------------------
TED notified ID: 214 
msg_id: 214, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 4344
---------------------------------------------------------------------
TED notified ID: 214 
msg_id: 214, retry_count: 0, acked: 1
more_frag: 0, frag_len: 215, frag_off: 5792
recomposition succeeded.
acked_avg: 1.00 retry_count_avg: 0.00
---------------------------------------------------------------------
TED notified ID: 219 
msg_id: 219, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 0
---------------------------------------------------------------------
TED notified ID: 219 
msg_id: 219, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 1448
---------------------------------------------------------------------
TED notified ID: 219 
msg_id: 219, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 2896
---------------------------------------------------------------------
					Sent pkt ID: 224
					size: 5999
---------------------------------------------------------------------
					Sent pkt ID: 229
					size: 5999
---------------------------------------------------------------------
TED notified ID: 219 
msg_id: 219, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 4344
---------------------------------------------------------------------
TED notified ID: 219 
msg_id: 219, retry_count: 0, acked: 1
more_frag: 0, frag_len: 215, frag_off: 5792
recomposition succeeded.
acked_avg: 1.00 retry_count_avg: 0.00
---------------------------------------------------------------------
TED notified ID: 224 
msg_id: 224, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 0
---------------------------------------------------------------------
TED notified ID: 224 
msg_id: 224, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 1448
---------------------------------------------------------------------
TED notified ID: 224 
msg_id: 224, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 2896
---------------------------------------------------------------------
TED notified ID: 224 
msg_id: 224, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 4344
---------------------------------------------------------------------
TED notified ID: 224 
msg_id: 224, retry_count: 0, acked: 1
more_frag: 0, frag_len: 215, frag_off: 5792
recomposition succeeded.
acked_avg: 1.00 retry_count_avg: 0.00
---------------------------------------------------------------------
TED notified ID: 229 
msg_id: 229, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 0
---------------------------------------------------------------------
TED notified ID: 229 
msg_id: 229, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 1448
---------------------------------------------------------------------
TED notified ID: 229 
msg_id: 229, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 2896
---------------------------------------------------------------------
TED notified ID: 229 
msg_id: 229, retry_count: 0, acked: 1
more_frag: 1, frag_len: 1448, frag_off: 4344
---------------------------------------------------------------------
TED notified ID: 229 
msg_id: 229, retry_count: 0, acked: 1
more_frag: 0, frag_len: 215, frag_off: 5792
recomposition succeeded.
acked_avg: 1.00 retry_count_avg: 0.00
---------------------------------------------------------------------

\end{lstlisting}

Le stampe per i messaggi inviati sono riportati sulla destra mentre
sulla sinistra sono riportate le stampe relative alle notifiche TED.\\

Per ogni notifica sono riportate le informazioni della struttura
\texttt{ted\_info\_s} e ogni volta che si incontra la notifica TED
relativa all'ultimo frammento per posizione (more fragment uguale a 0 e
fragment offset diverso da 0) si tenta la ricostruzione dei frammenti
precedenti. In caso di successo si stampano le medie dei valori
\texttt{ack} e \texttt{retry\_count}.\\

In questo esempio tutti i frame
802.11 sono arrivati al primo tentativo 
all'access point non essendoci problemi sul canale.
Nei lavori futuri si potrebbero effettuare test più significativi in
diversi scenari e sviluppare la gestione degli errori per la ricezione
delle notifiche TED come accennato nel paragrafo \ref{subsec:frag}.\\

\bibliography{biblio}{}
\bibliographystyle{plain}
\end{document}
